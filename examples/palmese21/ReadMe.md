# palmese21

These files test the inference from [Palmese+21](https://ui.adsabs.harvard.edu/abs/2021ApJ...914L..34P/abstract).

## `lambda_compare_likelihoods.py`

This file runs a test case for different parameter values.
The specifiable parameters are the flares-per-GW event $\lambda$, the background flares-per-AGN-per-follow-up-interval rate, and the random seed used to initialize the RNG.

### Input data

GWs are presently drawn from GWTC2.1, and are generally handled with teh `Skymap` class in https://github.com/tomas-cabrera/mygw/blob/main/src/mygw/io/skymaps.py.

The background AGN distribution is handled with a child of the `AGNDistribution` class in https://github.com/tomas-cabrera/myagn/blob/main/src/myagn/distributions.py; the default distribution assumes a constant physical density (Mpc$^{-3}$).

### Simulated dataset

The skymaps and AGN distribution are fed into [`mock_data`](https://github.com/tomas-cabrera/mygwagn/blob/80dbbe74f2c12f9deedeb189be597be593dc3ec6/src/mygwagn/inference/palmese21.py#L214) to draw the skymaps used and a respective population of background AGN flares.

GWs are drawn without replacement.
A known problem with using GWTC2.1 for this is that the presence of multiple skymaps for the same event with different waveforms means that the same event could be selected multiple times; this could cause an artificial overabundance of flares if follow-up volume overlaps are not properly handled.

#### GW counterpart flares

GW counterpart flares are generated by calculating the expected number with the number of events and the input $\lambda$.
This is converted into the used number of GW counterpart flares by either casting as an integer or drawing a value from a Poisson distribution with expectation equal to the computed value (this is toggled by `use_exact_rates`, and this method is used elsewhere in the code).

Once the number of flares is determined, GW events are selected for each counterpart flare without replacement.
The position of the flare is drawn from the GW skymap, and the time of the flare is drawn from a uniform distribution over the follow-up window.
In the future this can be changed to use a theoretically-informed time prior.

#### Background flares

When calculating the number of background flares, each GW volume is considered to be followed-up for a time after the event equal to the specified follow-up window.
To account for overlap among events, an "`active_skymap`" is maintained, which is a flat skymap with a Boolean mask indicating the active HEALPixs.
As GW follow-up periods begin or expire, the 90% CI HEALPix tiles for the respective GW skymap are added to the `active_skymap`, along with the minimum and maximum redshifts for that tile.
Presently, the `active_skymap` stores only the minimum/maximum of the minimum/maximum redshift values across GW events; this means that the redshift space between events is mistakenly included in the active follow-up volume calculation.
However, this method produces smaller volumes overall than `ligo.skymap.postprocess.crossmatch.crossmatch`, which is strange.

At any rate, the `active_skymap` volume recalculated every time a GW follow-up begins or terminates, and the time that `active_skymap` was active is recorded.
This time, the volume of the `active_skymap`, and the flare rate are used to calculate an expected number of flares which is converted into a used number as for the GW counterpart flare selection.

Background flare coords are drawn from the `active_skymap`.
The HEALPix is chosen randomly, and then a redshift is drawn from the prescribed AGN distribution between the minimum and maximum redshifts for that tile.
Times are chosen from a uniform distribution over the follow-up interval.

#### Wrap-up

The resulting GW events and AGN flares are cast into suitable objects.
Finally, the flares are cross-matched with the GW events to determine which flares fall into which follow-up campaigns (volume + time constrained); this information is recorded in `assoc_matrix`, a $n_{\rm gw} \times n_{\rm flare}$ Boolean matrix that is True where the flare falls in the GW volume.

### Calculating s_arr and b_arr

The resulting GW events, AGN flares, and `assoc_matrix` are then fed into a [`Framework`](https://github.com/tomas-cabrera/mygwagn/blob/80dbbe74f2c12f9deedeb189be597be593dc3ec6/src/mygwagn/inference/palmese21.py#L620) object, which is used to pre-calculate the GW association and background association terms (`s_arr` and `b_arr`).
This pre-calculation is only possible for the inference over $\lambda$; when inferring cosmology, the terms must be recalculated every step.

### Inference

To avoid passing the GW and AGN data during inference, a separate [`Lambda`](https://github.com/tomas-cabrera/mygwagn/blob/80dbbe74f2c12f9deedeb189be597be593dc3ec6/src/mygwagn/inference/palmese21.py#L762) object is initialized with the defined `Framework`.
After saving the `s_arr` and `b_arr` arrays along with the `assoc_matrix` array to the `Lambda` object, the inference is run with the `run_mcmc` method.
The inference is run for several different likelihoods in order to compare the results from each.
Statistics and plots from each inference are saved.